package day5

import (
	"bufio"
	"context"
	"fmt"
	"os"
	"time"
)

//Generated by AoC helper tool ðŸŽ„
//In order to get started, extend main.go so it discovers and runs this file as well

type Day5Solver struct{}

type GuardMap struct {
	wide           int
	tall           int
	obstacles      [][]int
	guard          []int
	guardChar      rune
	direction      int
	visited        map[string]int
	guardStart     []int
	guardCharStart rune
}

func (g GuardMap) PrintMap() {
	fmt.Print("\033[H\033[2J")
	for i := 0; i < g.tall; i++ {
		for j := 0; j < g.wide; j++ {
			if g.guard[0] == i && g.guard[1] == j {
				print(string(g.guardChar))
			} else {
				found := false
				for _, obstacle := range g.obstacles {
					if obstacle[0] == i && obstacle[1] == j {
						print("#")
						found = true
						break
					}
				}

				if visited, ok := g.visited[fmt.Sprintf("%d-%d", i, j)]; ok && visited == 1 {
					print("\033[32m.\033[0m")
					found = true
				}

				if visited, ok := g.visited[fmt.Sprintf("%d-%d", i, j)]; ok && visited > 1 {
					print("\033[31m.\033[0m")
					found = true
				}

				if !found {
					print(".")
				}
			}
		}
		println()
	}
}

var guardChars = map[int]rune{
	0: '^',
	1: '>',
	2: 'v',
	3: '<',
}

func (g *GuardMap) MoveGuard() bool {
	for _, obstacle := range g.obstacles {
		switch g.direction {
		case 0:
			if g.guard[0]-1 == obstacle[0] && g.guard[1] == obstacle[1] {
				g.direction = 1
				g.guardChar = guardChars[g.direction]
			}
		case 1:
			if g.guard[0] == obstacle[0] && g.guard[1]+1 == obstacle[1] {
				g.direction = 2
				g.guardChar = guardChars[g.direction]
			}
		case 2:
			if g.guard[0]+1 == obstacle[0] && g.guard[1] == obstacle[1] {
				g.direction = 3
				g.guardChar = guardChars[g.direction]
			}
		case 3:
			if g.guard[0] == obstacle[0] && g.guard[1]-1 == obstacle[1] {
				g.direction = 0
				g.guardChar = guardChars[g.direction]
			}
		}
	}

	switch g.direction {
	case 0:
		g.guard[0]--
	case 1:
		g.guard[1]++
	case 2:
		g.guard[0]++
	case 3:
		g.guard[1]--
	}

	if g.guard[0] < 0 {
		return true
	}
	if g.guard[0] >= g.tall {
		return true
	}
	if g.guard[1] < 0 {
		return true
	}
	if g.guard[1] >= g.wide {
		return true
	}
	g.visited[fmt.Sprintf("%d-%d", g.guard[0], g.guard[1])]++

	g.PrintMap()
	time.Sleep(20 * time.Millisecond)
	return false
}

func (g GuardMap) CopyGuardMap() *GuardMap {

	newMap := &GuardMap{
		wide:      g.wide,
		tall:      g.tall,
		guard:     append([]int{}, g.guardStart...),
		guardChar: g.guardCharStart,
		direction: 0,
		visited:   make(map[string]int),
		obstacles: g.obstacles,
	}

	return newMap
}

func loopMap(ctx context.Context, newMap *GuardMap, isGoodChan chan bool) {
	for {
		select {
		case <-ctx.Done():
			return
		default:
			if newMap.MoveGuard() {
				isGoodChan <- false
				return
			}
		}
	}
}

func (d Day5Solver) Solve(filename string, answerChan chan int, doneChan chan bool, errorChan chan error) {
	defer close(answerChan)
	defer close(errorChan)
	file, err := os.Open(filename)

	if err != nil {
		errorChan <- err
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)

	var gMap GuardMap
	gMap.visited = make(map[string]int)

	i := 0
	for scanner.Scan() {
		line := scanner.Text()
		if gMap.wide == 0 {
			gMap.wide = len(line)
		}

		for index, char := range line {
			if char == '#' {
				gMap.obstacles = append(gMap.obstacles, []int{i, index})
			} else if char == '^' {
				gMap.guard = []int{i, index}
				gMap.guardChar = char
				gMap.direction = 0
				gMap.visited[fmt.Sprintf("%d-%d", i, index)] = 0
				gMap.guardStart = []int{i, index}
				gMap.guardCharStart = char
			} else {
				gMap.visited[fmt.Sprintf("%d-%d", i, index)] = 0
			}
		}
		i++
	}
	gMap.tall = i

	steps := 0
	for gMap.MoveGuard() == false {
		steps++
	}

	vCount := 0
	for _, cell := range gMap.visited {
		if cell > 0 {
			vCount++
		}
	}

	loopCount := 0
	for i := 0; i < gMap.tall; i++ {
		for j := 0; j < gMap.wide; j++ {
			ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)

			newObstacle := []int{i, j}
			newMap := gMap.CopyGuardMap()
			newMap.obstacles = append(newMap.obstacles, newObstacle)

			isGoodChan := make(chan bool)

			go loopMap(ctx, newMap, isGoodChan)

			fmt.Print("\033[H\033[2J")
			fmt.Printf("Checking %d-%d\n", i, j)
			select {
			case <-isGoodChan:
				fmt.Println("No loop found")
			case <-ctx.Done():
				loopCount++
				fmt.Println("Loop found")
			}

			cancel()
			close(isGoodChan)
		}
	}

	answerChan <- vCount
	answerChan <- loopCount

	time.Sleep(3 * time.Second)
	doneChan <- true
}
